## Skiplist

跳表，作为 Memtable 的存储结构，具有数据有序、存取高效等特点。它是基于概率的链表结构，在随机数据分布均匀的情况下，性能可以媲美平衡树（如红黑树），存取时间复杂度可达到 O(log(n))。在代码实现上也更加简单，可以较好地替代平衡树。      

### 基本原理
![skiplist image1](../img/skiplist_random.png "实际分布") 
<center>图1：跳表实际分布</center>

#### 多级链表
跳表本质是一个链表结构，节点有多个 next 指针。节点有一个高度属性，高度等于 next 指针数量，每个 next 可以指向不同的后继节点，进而在逻辑上划分了不同的层级，高度为k的节点称为k级节点。       
在链表中会加入一个头节点，只用于表示链头，不会存值。

#### 数据有序
节点按值大小进行升序/降序排序。   

**查找规则**    
从最高一级开始查询，将目标值与当前节点的后继节点进行比较，如果后继节点值大于目标值或者后继节点为空，会先移动到下一层级，然后再进行比较，否则，继续向前遍历后继节点。    

**一个查找示例**   
在图1 跳表中，查找数字12：  
从第四层级（最高一级）开始，当前为头节点，后继节点 6 < 12 ，遍历节点6；
节点6 后继节点为空，移动到下一层级；
在第三层级，后继节点 25 > 12，移动到下一层级；
在第二层级，后继节点 9 < 12，遍历到节点 9；
在第二层级，后继节点 17 > 12， 移动到下一层级；
在第一层级，后继节点 12 = 12，找到目标值。    

**插入规则**    
节点在插入时，先通过查找规则找到合适的插入位置，然后更新每一层级前任节点和自身的 next 指针。  

**一个插入示例**   
在图1 跳表中，插入高度为3，值为11的节点：   
先找到插入位置，在节点9 和节点12 之间；  
高度是3，需要更新三个层级的 next 指针；   
在第三层级，前任节点是节点6，将节点6 的 next 指针指向新节点11，新节点11 指向原来节点6 的后继节点25；   
在第二和第一层级，前任节点都是节点9，同理更改层级 next 即可。   

#### 定义分支
跳表有一个分支属性，可以表现出二叉/多叉树的效果。    

![skiplist image2](../img/skiplist_uniform.png "理想分布")
<center>图2：跳表理想分布</center>

**类比二叉树**    
以平衡二叉树为例，查询元素时，每次比较可以跳过一半节点。为了实现同样的效果，跳表设置分支数为2，每上升一个层级，节点的数量将减少一半，同时达到相同层级的节点呈现均匀分布，如图2所示（即每隔两个节点，有一个 height >= 2 的节点，每隔四个节点，有一个 height >= 3 的节点，以此类推）。通过这种机制，跳表每次比较也可以跳过一半节点，表现出二叉树的性质。     

**时间复杂度**     
假设跳表节点数为 n，跳表高度为 H，分支数为2，那么 height >= 2 的节点数是 n / 2，height >= 3 的节点数是 n / 4，以此类推，height >= H 的节点数是 1 = n / 2**(h-1)（2的h-1次幂），跳表高度 H = log2(n) + 1。    
从图2可以看出，跳表的查找次数等于高度，所以时间复杂度为 O(H)，也就是O(log(n))，这跟平衡二叉/多叉树是一致的。   

**节点分布**   
节点分布规律：分支为2 时，对于达到层级 i 的节点，其中有一半会达到层级 i+1，很显然，不同层级节点分布满足：层级1占比50%，层级2占比25%，层级3占比12.5%，依次类推。   

**注：** 节点高度 h 代表节点所处的层级k，而达到层级 k 的节点是满足 h >= k 的所有节点。  


#### 随机机制
对于图2 中跳表的节点分布是理想情况下的实现，实际的节点分布如图1 所示。

**实现上的权衡**   
由于跳表实际使用时，节点数通常是动态变化的，会不断有新节点插入或者旧节点删除。如果要保证每一层节点均匀分布，在每次插入或删除节点时，需要对跳表的结构进行大规模调整，以重新分配各个节点的高度，这会使得时间复杂度显著增加，影响写性能。
因此，在实现跳表结构时，节点的高度采用随机函数生成的方式，给定一个分支数 b，使得层级 i 的节点达到层级 i+1 的概率为 p = 1/b，即 P(h=i+1) = P(h=i) * (1-1/b)（P(i=1) = 1-1/b）。

**概率分布**   
设跳表分支为2，概率 p = 1/2，P(h=i+1) = P(h=i) * 1/2，那么各个层级节点的概率如下：
P(h=1) = 1/2，   
P(h=2) = 1/4，   
...
P(h=k) = 1/2**(k-1)。   
达到每一层级的节点概率如下：
P(h=1) = 1，
P(h>=2) = 1 - P(h=1) = 1/2，
P(h>=3) = 1 - P(h=1) - P(h=2) = 1/4，
...
P(h>=k) = 1 - P(h=1) - P(h=2) - ... - P(h=k-1) = 1/2**(k-1)。   
由概率分布可以看出，只要随机函数的数据分布是否足够均匀，每一层级节点数可以满足节点分布规律，呈现出二叉树的性质。也就是说，随机的跳表结构平均性能是可以保证的，复杂度可以接近理想情况 O(log(n))。

**高度限制**   

#### 运行效果
跳表每次查找都会跳过一定数量的节点，这就是跳表加快查询速度的原因。在分支数为2 时，最理想的效果就是每次跳过一半的节点。


### 内部实现
这里会删除一些逻辑无关的代码，如模板相关的代码。    

#### 随机高度实现    

```
// db/skiplist.h
int SkipList::RandomHeight() {
  // Increase height with probability 1 in kBranching
  static const unsigned int kBranching = 4;
  int height = 1;
  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  ...
  return height;
}
```
LevelDB 内部跳表是4分支的。     
还是以2分支为例。
#### 查找实现
```

Node* SkipList::FindGreaterOrEqual(const Key& key, Node** prev) const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (KeyIsAfterNode(key, next)) {
      // Keep searching in this list
      x = next;
    } else {
      if (prev != NULL) prev[level] = x;
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }
  }
}

bool SkipList::KeyIsAfterNode(const Key& key, Node* n) const {
  // NULL n is considered infinite
  return (n != NULL) && (compare_(n->key, key) < 0);
}
```
会找到满足 >=key 的第一个节点。

为什么不直接找到相等的节点呢？

### 源码
```
db/skiplist.h
```


### 小结
不论是数据的读操作还是写操作，跳表都是比较高效的，在 levelDB 较大规模的写频繁的场景下，跳表会比红黑树展现出更好的性能。