## BloomFilter
布隆过滤器用于判断一个元素是否存在于集合中，它不像哈希表，不需要存储元素本身，而是使用位数组代表集合，空间效率极高，但它可能会把不存在于数据集合中的元素判断为存在，出现误判/假阳性（false positive）。   

假阳性：一个元素存在于集合中，定义为阳性。若一个元素存在于集合中，被布隆过滤器判断为存在，为真阳性；若一个元素不存在于集合中，被布隆过滤器判断为存在，则为假阳性。

### 原理
布隆过滤器本质上由一个位数组和 k 个哈希函数组成。位数组用于标记元素，k 个哈希函数用于将元素随机映射到位数组的 k 个位，当一个元素映射的 k 个位都为 1 时，表示元素<b>“可能存在”</b>于集合中（由于误判的存在，是不能确定元素一定存在的）。

#### 一个例子
下面以字符串为例，通过三个步骤来理解其工作原理：初始化、添加元素和判断元素。
**1.初始化**
指定 k=3，选择 3 个彼此独立的哈希函数：h1、h2、h3；        
分配一个长度为 10 的位数组，所有位的初始值都设为 0。
```
// 每个元素表示一个比特位，不是整数也不是布尔值
bit array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
index:      0  1  2  3  4  5  6  7  8  9
```    

**2.添加元素**    
添加字符串 "dog"，将其输入到 3 个哈希函数中，哈希函数会输出范围 [0, 9] 的位索引；    
假设 h1("dog") = 1，h2("dog") = 4，h3("dog") = 7；    
在位数组中将这些索引对应的值都设置为 1。   

```
Before: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
After:  [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]
            ^        ^        ^
            1        4        7
```

**3.判断元素**    
查询字符串 "dog"，同样将其输入到 3 个哈希函数中，得到索引：1, 4, 7；    
检查位数组中这些索引对应的值，发现都为 1，判断 "dog" 为存在。    

同理，查询字符串 "cat"，假设得到索引：1, 4, 9；   
检查位数组中这些索引对应的值，发现索引 1 和 4 是 1，但索引 9 是 0，判断 "cat" 为不存在。    

**误判情形**    
现在添加字符串 "cat"，将索引对应的值设置为 1，此时位数组索引 1, 4, 7, 9 为 1；   
然后查询字符串 "bird"，将其输入到 3 个哈希函数中，假设得到索引：1, 7, 9；   
检查位数组，发现索引 1, 7, 9 都为 1，判断 "bird" 为存在！    

显然，当前集合中并没有 "bird"，但布隆过滤器将其判断为存在，为什么会出现这种情况呢？     
这是由于每个哈希函数都存在哈希碰撞，它会使不同元素在哈希时可能会映射到相同位，导致元素的 k 个映射位部分共享，从而让布隆过滤器出现误判（假阳性）。

根据布隆过滤器的运行原理可知，元素所有映射位都为 1，只表示“可能存在”，而至少有一个映射位为 0，表示“一定不存在”。

#### 重要结论
布隆过滤器判断为“存在”可能是不准确的，只表示“可能存在”；   
布隆过滤器判断为“不存在”是 100% 准确的，表示“一定不存在”。     

实际应用时，会先通过布隆过滤器过滤掉“元素不存在”的请求，再去集合中进行查找“可能存在”的元素。

#### 性能优势
在需要快速判断元素是否存在的场景中，我们一般会使用哈希表，查询时间复杂度为常数 O(1)，但哈希表存储所有元素本身，当集合非常庞大时，会占用大量内存。    
相比于哈希表，布隆过滤器的优势在于：
1）空间效率极高：它不存储元素本身，只使用一个位数组和几个哈希函数，因此占用的空间远小于哈希表。
2）查询时间极快：插入和查询操作的时间复杂度都是常数 O(k)，k 是哈希函数的个数。

#### 误判率
误报率，即假阳性率（false positve rate），在这里指的是不存在于集合的元素被判断为存在的比例。

与布隆过滤器误判率有关的参数有：
**1.位数组大小 m**：m 越大，可供映射的位置越多，发生哈希碰撞的概率就越低，误判率也随之降低。但 m 越大，消耗的内存也越多，也就是通过空间换取精度;     
**2.哈希函数的个数 k**：哈希函数太少，会导致每个元素的映射位不足，容易发生碰撞；哈希函数太多，又会很快将位数组填满（全部变为1），导致误判率急剧上升；
**3.插入的元素数量 n**：随着加入的元素越来越多，位数组里 1 的比例越来越高，误判率也会自然升高。

那么，如何通过调整这三个参数让误报率尽可能小呢？
理论上讲，如果要将误判率控制在 a 以内，首先需满足：m/n >= ln(1/a) / (ln2)<sup>2</sup>，m/n 是负载因子，表示平均每个元素分摊到的比特数；在给定 m/n 的前提下，参数 k 需取最优值： k = (m/n) * ln2。     
注：实际上由于工程实现上的偏差，如哈希函数的分布不够均匀、插入元素数量超出预期导致 m/n 偏小等，会使误判率不能严格控制在 a 以内，如果这种偏差不大，略微超过 a 也是可以接受的。     

**参数设置**     
假设 a = 1% ，代入公式 m/n >= 9.6，取整，得 m/n 至少等于 10，k 取最优值 7。由此可知，设置 m/n = 10，k = 7，可使得过滤器的误判率约为 1%。

### 实现
leveldb 中利用布隆过滤器判断指定的 key 是否存在于 sstable 中，若过滤器判断为不存在，就不再需要去读取 data block，从而减少磁盘IO次数，提高读性能。

#### 参数设置
设置负载因子 m/n 和 哈希函数个数 k 。
```
// utils/bloom.cc
// BloomFilterPolicy 用于生成
class BloomFilterPolicy : public FilterPolicy {
 private:
  // 对应 m/n，指每个元素分摊到的比特数
  size_t bits_per_key_;
  // 哈希函数的个数
  size_t k_;
public:
  explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // 计算最优 k 值，这里采用向下取整，向上和向下取整都是可行的，对误报率影响很小。
    k_ = static_cast<size_t>(bits_per_key * 0.69); // 0.69 =~ ln(2)
    // 限制 k 的最小值和最大值
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }
  ...
};
```
#### 创建过滤器
包括初始化位数组，标记集合的中所有元素。
```
class BloomFilterPolicy : public FilterPolicy {
  ...
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (size_t i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += delta;
      }
    }
  }
  ...
};
```

#### 判断元素
```
class BloomFilterPolicy : public FilterPolicy {
  ...
  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }
    return true;
  }
};
```
### 应用场景
布隆过滤器会缓存在内存中，对“一定不存在”的查询进行快速过滤，可用于解决缓存穿透、数据库查询优化、垃圾邮件/恶意网址过滤等场景。

#### 解决缓存穿透
当查询一个根本不存在的键时，由于缓存层（如 Redis）中不存在该键，这个请求会穿透缓存层，直接到达数据库。如果有大量恶意请求或爬虫随机查询不存在的键，会对数据库造成巨大压力，甚至击垮数据库。在缓存层前放置一个布隆过滤器，可以拦截掉绝大部分非法查询，保护后端数据库。

#### 数据库查询优化
数据库一般会将数据块缓存在缓冲池中，如果查询的数据没有在缓冲池中命中，就需要从磁盘读取相应数据块并缓存。磁盘 I/O 是高开销操作，一次磁盘访问延迟可能在毫秒（ms）级别，如果该数据根本不存在，那么这种高开销操作不仅没有取得任何收益，而且还可能会将缓存池中真正有用的“热数据”替换为新读取的块，导致缓存命中率下降。当这种无效查询过多，数据库的性能将严重下降。引入布隆过滤器，可以对无效查询进行过滤，进而减少磁盘 I/O，提高缓存命中率。        

通过布隆过滤器查询数据，流程如下：    
1.查询到来时，先使用驻留在内存中的布隆过滤器进行预检；
2.如果布隆过滤器判断为“不存在”，系统可以立即返回“未找到”，完全避免了这次磁盘 I/O；
3.只有在布隆过滤器判断为“存在”时，才需要去执行真正的磁盘查找。

注：在 sstable 中查找指定的 key 就属于此类应用。   

### 小结
布隆过滤器是一个高效的数据结构，在能容忍低错误率的应用场合下，布隆过滤器通过极少的错误换取了存储空间的极大节省。

### 源码
```
utils/bloom.cc
include/filter_policy.h
```